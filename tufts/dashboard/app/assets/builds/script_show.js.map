{
  "version": 3,
  "sources": ["../../javascript/dynamic_forms.js", "../../javascript/script_show.js"],
  "sourcesContent": ["'use strict';\n\n// these are initialized in makeChangeHandlers\nvar idPrefix = undefined;\nvar shortNameRex = undefined;\n\n// @example ['NodeType', 'Cluster']\nconst formTokens = [];\n\n// simple lookup table to indicate that the change handler is setup between two\n// elements. I.e., {'cluster': [ 'node_type' ] } means that changes to cluster\n// trigger changes to node_type\nconst optionForHandlerCache = {};\nconst exclusiveOptionForHandlerCache = {};\n\n\n// simples array of string ids for elements that have a handler\nconst minMaxHandlerCache = [];\nconst setHandlerCache = [];\n// hide handler cache is a map in the form '{ from: [hideThing1, hideThing2] }'\nconst hideHandlerCache = {};\nconst labelHandlerCache = {};\n\n// Lookup tables for setting min & max values\n// for different directives.\nconst minMaxLookup = {};\nconst setValueLookup = {};\nconst hideLookup = {};\nconst labelLookup = {};\n\n// the regular expression for mountain casing\nconst mcRex = /[-_]([a-z])|([_-][0-9])|([\\/])/g;\n\n// whether we're still initializing or not\nlet initializing = true;\n\nfunction idWithPrefix(name) {\n  return `${idPrefix}_${name.toLowerCase()}`;\n};\n\n// here the simple name for 'batch_connect_session_context_cluster'\n// is just 'cluster'.\nfunction shortId(elementId) {\n  const match = elementId.match(shortNameRex);\n\n  if (match.length >= 1) {\n    return match[1];\n  } else {\n    return '';\n  };\n};\n\n/**\n * Mountain case the words from a string, by tokenizing on [-_].  In the\n * simplest case it just capitalizes.\n *\n * There is a special case where seperators are followed numbers. In this case\n * The seperator is kept as a hyphen because that's how jQuery expects it.\n *\n * @param      {string}  str     The word string to mountain case\n *\n * @example  given 'foo' this returns 'Foo'\n * @example  given 'foo-bar' this returns 'FooBar'\n * @example  given 'physics_1234' this returns 'Physics-1234'\n */\n// Convert dashed to camelCase\nfunction mountainCaseWords(str) {\n  const lower = str.toLowerCase();\n  const first = lower.charAt(0).toUpperCase();\n  const rest = lower.slice(1).replace(mcRex, function(_all, letter, prefixedNumber, slash) {\n    if(letter){\n      return letter.toUpperCase();\n    }else if(prefixedNumber){\n      return prefixedNumber.replace('_','-');\n    }else if(slash){\n      return '_';\n    }\n  });\n\n  return  `${first}${rest}`;\n}\n\n/**\n * Format passed string to snake_case. All characters become lowercase. Existing\n * underscores are unchanged and dashes become underscores. Underscores are added \n * before locations where an uppercase character is followed by a lowercase character.\n *\n * @param      {string}  str     The word string to snake case\n *\n * @example  given 'MountainCase' this returns 'mountain_case'\n * @example  given 'camelCase' this returns 'camel_case'\n * @example  given 'OSC_JUPYTER' this returns 'osc_jupyter'\n */\nfunction snakeCaseWords(str) {\n  if(str === undefined) return undefined;\n\n  // find all the captial case words and if none are found, we'll just bascially\n  // return the same string.\n  const rex = /([A-Z]{1}[a-z]*[0-9]*)|([^-_]+)/g;\n  const words = str.match(rex);\n\n  // filter out emtpy matches to avoid having a _ at the end.\n  return words.filter(word => word != '').map(word => word.toLowerCase()).join('_');\n}\n\n/**\n *\n * @param {Array} elements\n */\nfunction memorizeElements(elements) {\n  elements.each((_i, ele) => {\n    formTokens.push(mountainCaseWords(shortId(ele['id'])));\n  });\n};\n\nfunction makeChangeHandlers(prefix){\n\n  // initialize some global variables.\n  idPrefix = prefix;\n  shortNameRex = new RegExp(`${idPrefix}_([\\\\w\\\\-]+)`);\n\n  const allElements = $(`[id^=${idPrefix}]`);\n  memorizeElements(allElements);\n\n  allElements.each((_i, element) => {\n    if (element['type'] == \"select-one\"){\n      let optionSearch = `#${element['id']} option`;\n      let options = $(optionSearch);\n      options.each((_i, opt) => {\n          // the variable 'opt' is just a data structure, not a jQuery result. \n          // it has no attr, data, show or hide methods so we have to query\n          // for it again\n          let data = $(`${optionSearch}[value='${opt.value}']`).data();\n          let keys = Object.keys(data);\n          if(keys.length !== 0) {\n            keys.forEach((key) => {\n              if(key.startsWith('optionFor')) {\n                let token = key.replace(/^optionFor/,'');\n                addOptionForHandler(idFromToken(token), element['id']);\n              } else if (key.startsWith('exclusiveOptionFor')) {\n                let token = key.replace(/^exclusiveOptionFor/, '');\n                addExclusiveOptionForHandler(idFromToken(token), element['id']);\n              } else if(key.startsWith('max') || key.startsWith('min')) {\n                addMinMaxForHandler(element['id'], opt.value, key, data[key]);\n              } else if(key.startsWith('set')) {\n                addSetHandler(element['id'], opt.value, key, data[key]);\n              } else if(key.startsWith('hide')) {\n                addHideHandler(element['id'], opt.value, key, data[key]);\n              } else if(key.startsWith('label')) {\n                addLabelHandler(element['id'], opt.value, key, data[key]);\n              }\n            });\n          }\n      });\n    } else if(element['type'] == \"checkbox\") {\n      let data = $(element).data();\n      let keys = Object.keys(data);\n      if(keys.length !== 0) {\n        keys.forEach((key) => {\n          if(key.startsWith('hide')) {\n            let tokens = parseCheckedWhen(key);\n            if(tokens !== undefined){\n              addHideHandler(element['id'], tokens['value'], tokens['key'], data[key]);\n            }\n          }\n        });\n      }\n    }\n  });\n\n  initializing = false;\n};\n\nfunction addHideHandler(optionId, option, key, configValue) {\n  const changeId = idFromToken(key.replace(/^hide/,''));\n\n  if(hideLookup[optionId] === undefined) hideLookup[optionId] = new Table(changeId, undefined);\n  const table = hideLookup[optionId];\n  table.put(changeId, option, configValue);\n\n  if(hideHandlerCache[optionId] === undefined) hideHandlerCache[optionId] = [];\n\n  if(!hideHandlerCache[optionId].includes(changeId)) {\n    const changeElement = $(`#${optionId}`);\n\n    changeElement.on('change', (event) => {\n      updateVisibility(event, changeId);\n    });\n\n    hideHandlerCache[optionId].push(changeId);\n  }\n\n  updateVisibility({ target: document.querySelector(`#${optionId}`) }, changeId);\n};\n\nfunction newLabel(changeElement, key) {\n  const selectedOptionLabelIndex = changeElement[0].selectedIndex;\n  const selectedOptionLabel = changeElement[0].options[selectedOptionLabelIndex];\n  return selectedOptionLabel.dataset[key];\n};\n\nfunction updateLabel(changeId, changeElement, key) {\n  $(`label[for=\"${changeId}\"]`)[0].innerHTML = newLabel(changeElement, key);\n}\n\nfunction addLabelHandler(optionId, option, key, configValue) {\n  const changeId = idFromToken(key.replace(/^label/, ''));\n  const changeElement = $(`#${optionId}`);\n\n  if(labelLookup[optionId] === undefined) labelLookup[optionId] = new Table(changeId, undefined);\n  const table = labelLookup[optionId];\n  table.put(changeId, option, configValue);\n\n  if(labelHandlerCache[optionId] === undefined) labelHandlerCache[optionId] = [];\n\n  if(!labelHandlerCache[optionId].includes(changeId)) {\n    changeElement.on('change', (event) => {\n      updateLabel(changeId, changeElement, key);\n    });\n  };\n\n  updateLabel(changeId, changeElement, key);\n};\n\n/**\n *\n * @param {*} subjectId batch_connect_session_context_node_type\n * @param {*} option gpu\n * @param {*} key maxNumCoresForClusterAnnieOakley\n * @param {*} configValue 42\n *\n * node_type:\n *   widget: select\n *   options:\n *    - [\n *        'gpu',\n *        data-max-num-cores-for-cluster-annie-oakley: 42\n *      ]\n */\nfunction addMinMaxForHandler(subjectId, option, key,  configValue) {\n  subjectId = String(subjectId || '');\n  configValue = parseInt(configValue);\n\n  const configObj = parseMinMaxFor(key);\n  const objectId = configObj['subjectId'];\n  // this is the id of the target object we're setting the min/max for.\n  // if it's undefined - there's nothing to do, it was likely configured wrong.\n  if(objectId === undefined) return;\n\n  const secondDimId = configObj['predicateId'];\n  const secondDimValue = configObj['predicateValue'];\n\n  // several subjects can try to change the object, so the table lookup key has to have both\n  const lookupKey = `${subjectId}_${objectId}`;\n  if(minMaxLookup[lookupKey] === undefined) minMaxLookup[lookupKey] = new Table(subjectId, secondDimId);\n  const table = minMaxLookup[lookupKey];\n  table.put(option, secondDimValue, {[minOrMax(key)] : configValue });\n\n  let cacheKey = `${objectId}_${subjectId}_${secondDimId}`;\n  if(!minMaxHandlerCache.includes(cacheKey)) {\n    const changeElement = $(`#${subjectId}`);\n\n    changeElement.on('change', (event) => {\n      toggleMinMax(event, objectId, secondDimId);\n    });\n\n    minMaxHandlerCache.push(cacheKey);\n  }\n\n  cacheKey = `${objectId}_${secondDimId}_${subjectId}`;\n  if(secondDimId !== undefined && !minMaxHandlerCache.includes(cacheKey)){\n    const secondEle = $(`#${secondDimId}`);\n\n    secondEle.on('change', (event) => {\n      toggleMinMax(event, objectId, subjectId);\n    });\n\n    minMaxHandlerCache.push(cacheKey);\n  }\n\n  toggleMinMax({ target: document.querySelector(`#${subjectId}`) }, objectId, secondDimId);\n}\n\n/**\n *\n * @param {*} optionId batch_connect_session_context_classroom\n * @param {*} option 'PHY_9000'\n * @param {*} key setAccount\n * @param {*} configValue 'phy3005'\n *\n * classroom:\n *   widget: select\n *   options:\n *    - [\n *        'Physics Maximum', 'PHY_9000',\n *        data-set-account: 'phy3005'\n *      ]\n */\nfunction addSetHandler(optionId, option, key, configValue) {\n  const k = key.replace(/^set/,'');\n  const id = String(idFromToken(k));\n  if(id === 'undefined') return;\n\n  // id is account. optionId is classroom\n  let cacheKey = `${id}_${optionId}`\n  if(setValueLookup[cacheKey] === undefined) setValueLookup[cacheKey] = new Table(optionId, undefined);\n  const table = setValueLookup[cacheKey];\n  table.put(option, undefined, configValue);\n\n  if(!setHandlerCache.includes(cacheKey)) {\n    const changeElement = $(`#${optionId}`);\n\n    changeElement.on('change', (event) => {\n      setValue(event, id);\n    });\n\n    setHandlerCache.push(cacheKey);\n  }\n\n  setValue({ target: document.querySelector(`#${optionId}`) }, id);\n}\n\nfunction setValue(event, changeId) {\n  const chosenVal = event.target.value;\n  const cacheKey = `${changeId}_${event.target['id']}`\n  const table = setValueLookup[cacheKey];\n  if (table === undefined) return;\n\n  const changeVal = table.get(chosenVal, undefined);\n\n  if(changeVal !== undefined) {\n    const element = document.getElementById(changeId);\n    if(element['type'] == 'checkbox') {\n      setCheckboxValue(element, changeVal);\n    } else {\n      element.value = changeVal;\n    }\n  }\n}\n\nfunction setCheckboxValue(checkbox, value) {\n  const positiveValue = checkbox.value;\n  if(value == positiveValue) {\n    checkbox.checked = true;\n  } else {\n    checkbox.checked = false;\n  }\n}\n\n/**\n *\n *  This is a simple table class to describe the relationship between\n *  two different element types as a table with named columns.\n *\n *  table.get('gpu','owens') would return the value shown.\n *\n *      'oakley'   |                    |                |\n *      'owens'    | { min: 3, max: 42} |                |\n *                 |  'gpu'             |   'hugemem'    |\n *\n * In the simple case, it's a 1d vector instead of a 2d matrix. This\n * allows for, say, gpu to have the same min & max across clusters.\n */\nclass Table {\n  constructor(x, y) {\n    // FIXME: probably need to make Vector class? Wouldn't want to add a flag to the constructor.\n    // we don't use x or y internally, though x is used externally.\n    this.x = x;\n    this.xIdxLookup = {};\n\n    this.y = y;\n    this.yIdxLookup = {};\n    this.table = y === undefined ? [] : [[]];\n  }\n\n  put(x, y, value) {\n    if(!x) return;\n    x = snakeCaseWords(x);\n    y = snakeCaseWords(y);\n\n    if(this.xIdxLookup[x] === undefined) this.xIdxLookup[x] = Object.keys(this.xIdxLookup).length;\n    if(y && this.yIdxLookup[y] === undefined) this.yIdxLookup[y] = Object.keys(this.yIdxLookup).length;\n\n    const xIdx = this.xIdxLookup[x];\n    const yIdx = this.yIdxLookup[y];\n\n    if(this.table[xIdx] === undefined ){\n      this.table[xIdx] = y === undefined ? undefined : [];\n    }\n\n    // if y's index is defined, then it's a 2d matrix. Otherwise a 1d vector.\n    if(yIdx === undefined) {\n      if(this.table[xIdx] === undefined){\n        this.table[xIdx] = value;\n      } else {\n        const prev = this.table[xIdx];\n        const newer = value;\n        if(typeof newer == 'string' && typeof prev == 'string'){\n          this.table[xIdx] = newer;\n        } else {\n          this.table[xIdx] = Object.assign(prev, newer);\n        }\n      }\n    } else {\n      if(this.table[xIdx][yIdx] === undefined){\n        this.table[xIdx][yIdx] = value;\n      } else {\n        const prev = this.table[xIdx][yIdx];\n        const newer = value;\n        if(typeof newer == 'string' && typeof prev == 'string'){\n          this.table[xIdx][yIdx] = newer;\n        } else {\n          this.table[xIdx][yIdx] = Object.assign(prev, newer);\n        }\n      }\n    }\n  }\n\n  get(x, y) {\n    const xIdx = this.xIdxLookup[snakeCaseWords(x)];\n    const yIdx = this.yIdxLookup[snakeCaseWords(y)];\n\n    if(this.table[xIdx] === undefined){\n      return undefined;\n    }else if(y === undefined){\n      return this.table[xIdx];\n    }else {\n      return this.table[xIdx][yIdx];\n    }\n  }\n}\n\n/**\n * Update the visibility of `changeId` based on the\n * event and what's in the hideLookup table.\n */\nfunction updateVisibility(event, changeId) {\n  const val = valueFromEvent(event);\n  const id = event.target['id'];\n  let changeElement = undefined;\n  \n  $(`#${changeId}`).parents().each(function(_i, parent) {\n    var classListValues = parent.classList.values();\n    for (const val of classListValues) {\n      // TODO: Using 'mb-3' here because 'form-group' was removed\n      // from Bootstrap 5 and replaced with 'mb-3' - however, this\n      // is a grid class which could (??) apply to parent elements\n      // in unpredictable parts of the chain - test for & resolve\n      if (val.match('mb-3')) {\n        changeElement = $(parent);\n      }\n    }\n  });\n\n  if (changeElement === undefined || changeElement.length <= 0) return;\n\n  // safe to access directly?\n  const hide = hideLookup[id].get(changeId, val);\n  if((hide === false) || (hide === undefined && !initializing)) {\n    changeElement.show();\n  }else if(hide === true) {\n    changeElement.hide();\n  }\n}\n\n// extract the value from the event. With checkbox being\n// handleded specially.\nfunction valueFromEvent(event) {\n  if(event.target['type'] == 'checkbox') {\n    return event.target.checked ? 'checked' : 'unchecked';\n  } else {\n    return event.target.value;\n  }\n}\n/**\n * Update the min & max values of `changeId` based on the\n * event, the `otherId` and the settings in minMaxLookup table.\n */\nfunction toggleMinMax(event, changeId, otherId) {\n  let x = undefined, y = undefined;\n\n  // many subjects can change the object, so we have to find the correct table\n  // in the form <subject>_<object>\n  let lookupKey = `${event.target['id']}_${changeId}`;\n  if(minMaxLookup[lookupKey] === undefined) {\n    lookupKey = `${otherId}_${changeId}`;\n  }\n\n  const table = minMaxLookup[lookupKey];\n\n  // in the example of cluster & node_type, either element can trigger a change\n  // so let's figure out the axis' based on the change element's id.\n  if(event.target['id'] == table.x) {\n    x = snakeCaseWords(event.target.value);\n    y = snakeCaseWords($(`#${otherId}`).val());\n  } else {\n    y = snakeCaseWords(event.target.value);\n    x = snakeCaseWords($(`#${otherId}`).val());\n  }\n\n  const changeElement = $(`#${changeId}`);\n  const mm = table.get(x, y);\n  const prev = {\n    min: parseInt(changeElement.attr('min')),\n    max: parseInt(changeElement.attr('max')),\n  };\n\n  [ 'max', 'min' ].forEach((dim) => {\n    if(mm && mm[dim] !== undefined) {\n      changeElement.attr(dim, mm[dim]);\n    }\n  });\n\n  const val = clamp(parseInt(changeElement.val()), prev, mm)\n  if (val !== undefined) {\n    changeElement.attr('value', val);\n    changeElement.val(val);\n  }\n}\n\nfunction clamp(currentValue, previous, next) {\n  if(next === undefined){\n    return undefined;\n\n  // you've set the boundary, so when you go to the next value - keep it at the next's boundary\n  } else if(currentValue === previous['min']) {\n    return next['min'];\n  } else if(currentValue === previous['max']) {\n    return next['max'];\n\n  // otherwise you could be up or down shifting to fit within the next's boundaries\n  } else if(currentValue <= next['min']) {\n    return next['min'];\n  } else if(currentValue >= next['max']) {\n    return next['max'];\n  } else {\n    return undefined;\n  }\n}\n\nfunction sharedOptionForHandler(causeId, targetId, optionForType) {\n  const changeId = String(causeId || '');\n  let handlerCache = null;\n\n  if (optionForType == 'optionFor') {\n    if (optionForHandlerCache[causeId] == undefined) optionForHandlerCache[causeId] = [];\n    handlerCache = optionForHandlerCache;\n  } else if (optionForType == 'exclusiveOptionFor') {\n    if (exclusiveOptionForHandlerCache[causeId] == undefined) exclusiveOptionForHandlerCache[causeId] = [];\n    handlerCache = exclusiveOptionForHandlerCache;\n  }\n  \n  if(changeId.length == 0 || handlerCache[causeId].includes(targetId)) {\n    // nothing to do. invalid causeId or we already have a handler between the 2\n    return;\n  }\n\n  let causeElement = $(`#${causeId}`);\n\n  if(targetId && causeElement) {\n    // cache the fact that there's a new handler here\n    handlerCache[causeId].push(targetId);\n\n    causeElement.on('change', (event) => {\n      if (optionForType == 'exclusiveOptionFor') {\n        toggleExclusiveOptionsFor(event, targetId);\n      } else if (optionForType == 'optionFor') {\n        toggleOptionsFor(event, targetId);\n      }\n    });\n\n    // fake an event to initialize\n    if (optionForType == 'exclusiveOptionFor') {\n      toggleExclusiveOptionsFor({ target: document.querySelector(`#${causeId}`) }, targetId);\n    } else if (optionForType == 'optionFor') {\n      toggleOptionsFor({ target: document.querySelector(`#${causeId}`) }, targetId);\n    }\n  }\n}\n\nfunction addOptionForHandler(causeId, targetId) {\n  sharedOptionForHandler(causeId, targetId, 'optionFor');\n};\n\nfunction addExclusiveOptionForHandler(causeId, targetId) {\n  sharedOptionForHandler(causeId, targetId, 'exclusiveOptionFor');\n};\n\nfunction parseCheckedWhen(key) {\n  const tokens = key.match(/^hide(\\w+)When(\\w+)$/);\n\n  if(tokens !== undefined && tokens.length && tokens.length == 3) {\n    return {\n      'key': tokens[1],\n      'value': tokens[2].toLowerCase() == 'checked' ? 'checked' : 'unchecked'\n    };\n  } else {\n    return undefined;\n  }\n}\n\n/**\n *\n * @param {*} key minNumCoresForClusterAnnieOakley\n * @returns\n *\n *  {\n *    'subjectId': 'batch_connect_session_context_num_cores',\n *    'predicateId': 'batch_connect_session_context_cluster',\n *    'predicateValue': 'annie_oakley'\n *  }\n */\nfunction parseMinMaxFor(key) {\n  let k = undefined;\n  let predicateId = undefined;\n  let predicateValue = undefined;\n  let subjectId = undefined;\n\n  if(key.startsWith('min')) {\n    k = key.replace(/^min/,'');\n  } else if(key.startsWith('max')) {\n    k = key.replace(/^max/, '')\n  }\n\n  //trying to parse maxNumCoresForClusterOwens\n  const tokens = k.match(/^(\\w+)For(\\w+)$/);\n\n  if(tokens == null) {\n    // the key is likely just maxNumCores with no For clause\n    subjectId = idFromToken(k);\n\n  } else if(tokens.length == 3) {\n    const subject = tokens[1];\n    const predicateFull = tokens[2];\n    subjectId = idFromToken(subject);\n\n    const predicateTokens = predicateFull.split(/(?=[A-Z])/);\n    if(predicateTokens && predicateTokens.length >= 2) {\n\n      // if there are only 2 tokens then it's like 'ClusterOwens' which is easy\n      if(predicateTokens.length == 2) {\n        predicateId = idFromToken(predicateTokens[0]);\n        predicateValue = predicateTokens[1];\n\n      // else it's like NodeTypeFooBar, so it's a little more difficult\n      } else {\n        let tokenString = '';\n        let done = false;\n        predicateTokens.forEach((pt, idx) => {\n          if(done) { return; }\n\n          tokenString = `${tokenString}${pt}`\n          let tokenId = idFromToken(tokenString);\n          if(tokenId !== undefined) {\n            done = true;\n            predicateId = tokenId;\n            predicateValue = predicateTokens.slice(idx+1).join('');\n          }\n        })\n      }\n    }\n  }\n\n  return {\n    'subjectId': subjectId,\n    'predicateId': predicateId,\n    'predicateValue': snakeCaseWords(predicateValue),\n  }\n}\n\nfunction minOrMax(key) {\n  if(key.startsWith('min')){\n    return 'min';\n  } else if(key.startsWith('max')){\n    return 'max';\n  } else {\n    return null;\n  }\n}\n\n/**\n * Turn a MountainCase token into a form element id\n *\n * @example\n *  NodeType -> batch_connect_session_context_node_type\n *\n * @param {*} str\n * @returns\n */\nfunction idFromToken(str) {\n  elements = formTokens.map((token) => {\n    let match = str.match(`^${token}{1}`);\n\n    if (match && match.length >= 1) {\n      let ele = snakeCaseWords(match[0]);\n      return idWithPrefix(ele);\n    }\n  }).filter((id) => {\n    return id !== undefined;\n  });\n\n  if(elements.length == 0) {\n    return undefined;\n  }else if(elements.length == 1) {\n    return elements[0];\n\n  // you matched multiple things. For example you're searching for\n  // ClusterFilesystem and matched against both 'Cluster' and 'ClusterFilesystem'.\n  // The correrct element id ends with cluster_filesystem.\n  } else if(elements.length > 1) {\n    const snake_case_str = snakeCaseWords(str);\n    return elements.filter((element) => {\n      return element.endsWith(snake_case_str);\n    })[0];\n  }\n}\n\n/**\n * Extract the option for out of an option for directive.\n *\n * @example\n *  optionForClusterOakley -> Cluster\n *  exclusiveOptionForClusterOakley -> Cluster\n *\n * @param {*} str\n * @returns - the option for string\n */\nfunction sharedOptionForFromToken(str, optionForType) {  \n  return formTokens.map((token) => {\n    let match = str.match(`^${optionForType}${token}`);\n\n    if (match && match.length >= 1) {\n      return token;\n    }\n  }).filter((id) => {\n    return id !== undefined;\n  })[0];\n}\n\nfunction optionForFromToken(str) {\n  return sharedOptionForFromToken(str, 'optionFor');\n}\n\nfunction exclusiveOptionForFromToken(str) {\n  return sharedOptionForFromToken(str, 'exclusiveOptionFor');\n}\n\nfunction sharedToggleOptionsFor(_event, elementId, contextStr) {\n  const options = [...document.querySelectorAll(`#${elementId} option`)];\n  let hideSelectedValue = undefined;\n\n  options.forEach(option => {\n    let hide = false;\n\n    // even though an event occured - an option may be hidden based on the value of\n    // something else entirely. We're going to hide this option if _any_ of the\n    // option-for- directives apply.\n    for (let key of Object.keys(option.dataset)) {\n      let optionFor = '';\n\n      if (contextStr == 'optionFor') {\n        optionFor = optionForFromToken(key);\n      } else if (contextStr == 'exclusiveOptionFor') {\n        optionFor = exclusiveOptionForFromToken(key);\n      }\n      let optionForId = idFromToken(key.replace(new RegExp(`^${contextStr}`),''));\n\n      // it's some other directive type, so just keep going and/or not real\n      if(!key.startsWith(contextStr) || optionForId === undefined) {\n        continue;\n      }\n\n      let optionForValue = mountainCaseWords(document.getElementById(optionForId).value);\n      // handle special case where the very first token here is a number.\n      // browsers expect a prefix of hyphens as if it's the next token.\n      if (optionForValue.match(/^\\d/)) {\n        optionForValue = `-${optionForValue}`;\n      }\n\n      if (contextStr == 'optionFor') {\n        hide = option.dataset[`optionFor${optionFor}${optionForValue}`] === 'false';\n      } else if (contextStr == 'exclusiveOptionFor') {\n        hide = !(option.dataset[`exclusiveOptionFor${optionFor}${optionForValue}`] === 'true')\n      }\n\n      if (hide) {\n        break;\n      }\n    };\n\n    if(hide) {\n      if(option.selected) {\n        option.selected = false;\n        hideSelectedValue = option.textContent;\n      }\n\n      option.style.display = 'none';\n      option.disabled = true;\n    } else {\n      option.style.display = '';\n      option.disabled = false;\n    }\n  });\n\n  // now that we've hidden/shown everything, let's choose what should now\n  // be the current selected value.\n  // if you've hidden what _was_ selected.\n  if(hideSelectedValue !== undefined) {\n    let others = [...document.querySelectorAll(`#${elementId} option[value='${hideSelectedValue}']`)];\n    let newSelectedOption = undefined;\n\n    // You have hidden what _was_ selected, so try to find a duplicate option that is visible\n    if(others.length > 1) {\n      others.forEach(ele => {\n        if(ele.style.display === '') {\n          newSelectedOption = ele;\n          return;\n        }\n      });\n    }\n\n    // no duplciates are visible, so just pick the first visible option\n    if (newSelectedOption === undefined) {\n      others = document.querySelectorAll(`#${elementId} option`);\n      others.forEach(ele => {\n        if(newSelectedOption === undefined && ele.style.display === '') {\n          newSelectedOption = ele;\n        }\n      });\n    }\n\n    if (newSelectedOption !== undefined) {\n      newSelectedOption.selected = true;\n    }\n  }\n\n  // now that we're done, propogate this change to data-set or data-hide handlers\n  document.getElementById(elementId).dispatchEvent((new Event('change', { bubbles: true })));\n}\n\nfunction toggleOptionsFor(_event, elementId) {\n  sharedToggleOptionsFor(_event, elementId, 'optionFor');\n}\n\nfunction toggleExclusiveOptionsFor(_event, elementId) {\n  sharedToggleOptionsFor(_event, elementId, 'exclusiveOptionFor');\n};\n\nexport {\n  makeChangeHandlers\n}\n", "import { makeChangeHandlers } from './dynamic_forms';\n\njQuery(function() {\n  makeChangeHandlers('launcher');\n});\n"],
  "mappings": "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",
  "names": ["idPrefix", "shortNameRex", "formTokens", "optionForHandlerCache", "exclusiveOptionForHandlerCache", "minMaxHandlerCache", "setHandlerCache", "hideHandlerCache", "labelHandlerCache", "minMaxLookup", "setValueLookup", "hideLookup", "labelLookup", "mcRex", "initializing", "idWithPrefix", "name", "shortId", "elementId", "match", "mountainCaseWords", "str", "lower", "first", "rest", "_all", "letter", "prefixedNumber", "slash", "snakeCaseWords", "rex", "word", "memorizeElements", "elements", "_i", "ele", "makeChangeHandlers", "prefix", "allElements", "element", "optionSearch", "opt", "data", "keys", "key", "token", "addOptionForHandler", "idFromToken", "addExclusiveOptionForHandler", "addMinMaxForHandler", "addSetHandler", "addHideHandler", "addLabelHandler", "tokens", "parseCheckedWhen", "optionId", "option", "configValue", "changeId", "Table", "event", "updateVisibility", "newLabel", "changeElement", "selectedOptionLabelIndex", "updateLabel", "subjectId", "configObj", "parseMinMaxFor", "objectId", "secondDimId", "secondDimValue", "lookupKey", "minOrMax", "cacheKey", "toggleMinMax", "k", "id", "setValue", "chosenVal", "table", "changeVal", "setCheckboxValue", "checkbox", "value", "positiveValue", "x", "y", "xIdx", "yIdx", "prev", "newer", "val", "valueFromEvent", "parent", "classListValues", "hide", "otherId", "mm", "dim", "clamp", "currentValue", "previous", "next", "sharedOptionForHandler", "causeId", "targetId", "optionForType", "handlerCache", "causeElement", "toggleExclusiveOptionsFor", "toggleOptionsFor", "predicateId", "predicateValue", "subject", "predicateFull", "predicateTokens", "tokenString", "done", "pt", "idx", "tokenId", "snake_case_str", "sharedOptionForFromToken", "optionForFromToken", "exclusiveOptionForFromToken", "sharedToggleOptionsFor", "_event", "contextStr", "options", "hideSelectedValue", "optionFor", "optionForId", "optionForValue", "others", "newSelectedOption", "makeChangeHandlers"]
}
